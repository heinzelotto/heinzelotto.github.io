<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Random Treasure Hunt</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

  <!-- Comic Mono Font -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/comic-mono@0.0.1/index.min.css">

  <style>
    body {
      margin: 0;
      padding: 20px;
      font-family: 'Comic Mono', system-ui, -apple-system, sans-serif;
    }

    #app {
      max-width: 800px;
      margin: 0 auto;
    }

    #map {
      height: 500px;
      width: 100%;
      margin: 20px 0;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    .start-screen {
      text-align: center;
      padding: 40px;
    }

    .start-button {
      padding: 15px 30px;
      font-size: 18px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }

    .start-button:disabled {
      padding: 15px 30px;
      font-size: 18px;
      background: #95c099;
      color: #999999;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }

    .start-button:hover:enabled {
      background: #45a049;
    }

    .progress {
      padding: 15px;
      background: #f5f5f5;
      border-radius: 5px;
      margin-bottom: 20px;
    }

    .waypoint-list {
      list-style: none;
      padding: 0;
    }

    .waypoint-item {
      padding: 10px;
      margin: 5px 0;
      background: white;
      border: 1px solid #ddd;
      border-radius: 5px;
    }

    .waypoint-item.completed {
      background: #e8f5e9;
      border-color: #4CAF50;
    }

    .location-controls {
      margin: 20px 0;
      text-align: left;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }

    .control-group {
      margin-bottom: 15px;
    }

    .control-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: bold;
    }

    .control-group input[type="text"] {
      width: 100%;
      padding: 8px;
      font-size: 14px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #f9f9f9;
      box-sizing: border-box;
    }

    .control-group input[type="range"] {
      width: 100%;
    }

    .range-labels {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      color: #666;
    }

    .feature-selector {
      max-width: 800px;
      margin: 20px auto;
      text-align: left;
    }

    .feature-category {
      margin-bottom: 20px;
      padding: 15px;
      background: #f9f9f9;
      border-radius: 5px;
      border: 1px solid #ddd;
    }

    .feature-category h3 {
      margin: 0 0 10px 0;
      font-size: 16px;
      color: #333;
    }

    .feature-checkboxes {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 8px;
    }

    .feature-checkbox {
      display: flex;
      align-items: center;
    }

    .feature-checkbox input[type="checkbox"] {
      margin-right: 8px;
    }

    .feature-checkbox label {
      cursor: pointer;
      user-select: none;
    }

    .hunt-length-option {
      cursor: pointer;
      padding: 10px 20px;
      border: 2px solid #ddd;
      border-radius: 5px;
      background: white;
      transition: all 0.3s ease;
    }

    .hunt-length-option:has(input:checked) {
      border-color: #4CAF50;
      background: #e8f5e9;
    }

    .hunt-length-option input[type="radio"] {
      margin-right: 8px;
    }

    .privacy {
      font-size: 0.9em;
      color: #666;
      text-align: center;
      margin-top: 30px;
      font-style: italic;
    }
  </style>
</head>

<body>
  <div id="app"></div>

  <!-- Leaflet JavaScript -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Your app code -->
  <script>
    // State interface
    let currentState = null;
    let map = null;
    let markers = [];
    let currentLocationMarker = null;
    let currentWatchId = null; // For watchPosition tracking
    let pathPolyline = null;
    let accuracyCircle = null;

    // Treasure hunt parameter state (is not stored to URL GET param)
    let selectedLocationMarker = null;
    let selectedAreaCircle = null;
    let selectedLocation = null;
    let selectedRadius = 500; // default 500 meters
    let selectedHuntLength = 'medium'; // default: short, medium, or long
    let startNearCenter = true; // start from POI closest to center point

    // Encode state to URL-safe string
    function encodeState(state) {
      const json = JSON.stringify(state);
      try {
        // Encode as UTF-8 bytes, then base64
        const utf8Bytes = new TextEncoder().encode(json);
        const binaryString = Array.from(utf8Bytes, byte => String.fromCharCode(byte)).join('');
        return encodeURIComponent(btoa(binaryString));
      } catch (e) {
        console.error('Failed to encode state:', e);
        // Fallback: try double encoding
        try {
          return encodeURIComponent(btoa(unescape(encodeURIComponent(json))));
        } catch (e2) {
          console.error('Fallback encoding also failed:', e2);
          return '';
        }
      }
    }

    // Decode state from URL parameter
    function decodeState(encoded) {
      try {
        const binaryString = atob(decodeURIComponent(encoded));
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        const json = new TextDecoder().decode(bytes);
        return JSON.parse(json);
      } catch (e) {
        console.error('Failed to decode state:', e);
        // Try fallback decoding
        try {
          const json = decodeURIComponent(escape(atob(decodeURIComponent(encoded))));
          return JSON.parse(json);
        } catch (e2) {
          console.error('Fallback decoding also failed:', e2);
          return null;
        }
      }
    }

    // Read state from URL
    function getStateFromURL() {
      const params = new URLSearchParams(window.location.search);
      const stateParam = params.get('state');

      if (stateParam) {
        return decodeState(stateParam);
      }
      return null;
    }

    // Update URL with new state (without page reload)
    function updateURLWithState(state) {
      const encoded = encodeState(state);
      const newURL = `${window.location.pathname}?state=${encoded}`;
      window.history.replaceState(null, '', newURL);
      currentState = state;
    }

    // Update selected location marker and circle
    function updateSelectedLocationDisplay() {
      if (!map || !selectedLocation) return;

      // Remove existing marker and circle
      if (selectedLocationMarker) {
        map.removeLayer(selectedLocationMarker);
      }
      if (selectedAreaCircle) {
        map.removeLayer(selectedAreaCircle);
      }

      // Add new marker
      const redIcon = L.icon({
        iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
        shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
        iconSize: [25, 41],
        iconAnchor: [12, 41],
        popupAnchor: [1, -34],
        shadowSize: [41, 41]
      });

      selectedLocationMarker = L.marker([selectedLocation.lat, selectedLocation.lng], { icon: redIcon })
        .addTo(map)
        .bindPopup('Play area center');

      // Add circle
      selectedAreaCircle = L.circle([selectedLocation.lat, selectedLocation.lng], {
        color: 'red',
        fillColor: '#f03',
        fillOpacity: 0.2,
        radius: selectedRadius
      }).addTo(map);

      // Fit map to show the circle
      map.fitBounds(selectedAreaCircle.getBounds(), { padding: [50, 50] });
    }

    // Use current location as play area center
    function useCurrentLocationForNewHunt() {
      if ('geolocation' in navigator) {
        // Disable button during acquisition
        setUseCurrentLocationButtonEnabled(false);

        navigator.geolocation.getCurrentPosition(
          (position) => {
            selectedLocation = {
              lat: position.coords.latitude,
              lng: position.coords.longitude
            };

            // Update the input field
            const locationInput = document.getElementById('location-input');
            if (locationInput) {
              locationInput.value = `${selectedLocation.lat.toFixed(6)}, ${selectedLocation.lng.toFixed(6)}`;
            }

            // Enable the start button
            document.getElementById("create-new-hunt-button").removeAttribute("disabled");

            // Update marker and circle
            updateSelectedLocationDisplay();

            // Re-enable button
            setUseCurrentLocationButtonEnabled(true);
          },
          (error) => {
            alert('Could not get your location: ' + error.message);
            // Re-enable button on error
            setUseCurrentLocationButtonEnabled(true);
          },
          {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 0
          }
        );
      } else {
        alert('Geolocation is not supported by your browser');
      }
    }

    // Show the start screen map
    function initStartScreenMap(currentLocation) {
      // Create map if it doesn't exist
      if (!map) {

        // Center on first waypoint or current location
        const center = currentLocation || { lat: 48.1651, lng: 11.5820 };
        map = L.map('map').setView([center.lat, center.lng], 13);

        L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
          attribution: '© OpenStreetMap contributors, © CARTO',
          subdomains: 'abcd',
          maxZoom: 20
        }).addTo(map);

        // Add click handler for location selection
        map.on('click', function (e) {
          selectedLocation = { lat: e.latlng.lat, lng: e.latlng.lng };

          // Update the input field
          const locationInput = document.getElementById('location-input');
          if (locationInput) {
            locationInput.value = `${selectedLocation.lat.toFixed(6)}, ${selectedLocation.lng.toFixed(6)}`;
          }

          // Enable the start button
          document.getElementById("create-new-hunt-button").removeAttribute("disabled");

          // Update marker and circle
          updateSelectedLocationDisplay();
        });
      }

      // Clear existing markers
      markers.forEach(marker => map.removeLayer(marker));

      // Add current location marker if available
      if (currentLocation) {
        const blueIcon = L.icon({
          iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
          shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          shadowSize: [41, 41]
        });

        currentLocationMarker = L.marker([currentLocation.lat, currentLocation.lng], { icon: blueIcon })
          .addTo(map)
          .bindPopup('You are here');
      }

      // Restore selected location display if it exists
      if (selectedLocation) {
        updateSelectedLocationDisplay();
      }

      // Fit map to show all markers
      if (markers.length > 0) {
        const bounds = L.latLngBounds(markers.map(m => m.getLatLng()));
        if (currentLocationMarker) {
          bounds.extend(currentLocationMarker.getLatLng());
        }
        map.fitBounds(bounds, { padding: [50, 50] });
      }
    }

    // Initialize or update the map
    function initMap(waypoints, completedIndices, currentLocation) {
      // Create map if it doesn't exist
      if (!map) {
        const mapDiv = document.createElement('div');
        mapDiv.id = 'map';
        document.getElementById('app').appendChild(mapDiv);

        // Center on first waypoint or current location
        const center = currentLocation || waypoints[0];
        map = L.map('map').setView([center.lat, center.lng], 13);

        L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
          attribution: '© OpenStreetMap contributors, © CARTO',
          subdomains: 'abcd',
          maxZoom: 20
        }).addTo(map);
      }

      // Clear existing markers
      markers.forEach(marker => map.removeLayer(marker));
      markers = [];
      if (currentLocationMarker) {
        map.removeLayer(currentLocationMarker);
        currentLocationMarker = null;
      }

      // Add waypoint markers
      waypoints.forEach((waypoint, index) => {
        const isCompleted = completedIndices.includes(index);

        // Create custom icon for completed waypoints
        let icon = undefined;
        if (isCompleted) {
          icon = L.icon({
            iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
            shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
          });
        }

        const marker = L.marker([waypoint.lat, waypoint.lng], icon ? { icon } : {})
          .addTo(map)
          .bindPopup(`
            <b>${waypoint.name}</b><br>
            ${isCompleted ? '✓ Completed' : 'Not visited yet'}
          `);

        markers.push(marker);
      });

      // Add current location marker if available
      if (currentLocation) {
        const blueIcon = L.icon({
          iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
          shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          shadowSize: [41, 41]
        });

        currentLocationMarker = L.marker([currentLocation.lat, currentLocation.lng], { icon: blueIcon })
          .addTo(map)
          .bindPopup('You are here');
      }

      // Fit map to show all markers
      if (markers.length > 0) {
        const bounds = L.latLngBounds(markers.map(m => m.getLatLng()));
        if (currentLocationMarker) {
          bounds.extend(currentLocationMarker.getLatLng());
        }
        map.fitBounds(bounds, { padding: [50, 50] });
      }
    }

    // Handle radius change
    function handleRadiusChange() {
      const radiusInput = document.getElementById('radius-input');
      const radiusValue = document.getElementById('radius-value');

      if (radiusInput && radiusValue) {
        selectedRadius = parseInt(radiusInput.value);
        radiusValue.textContent = selectedRadius;

        // Update circle if location is selected
        if (selectedLocation) {
          updateSelectedLocationDisplay();
        }
      }
    }

    // Render start screen
    function renderStartScreen() {
      document.getElementById('app').innerHTML = `
        <div class="start-screen">
          <h1>Random Treasure Hunt</h1>
          <p>Click on the map to select your play area center, or 
            <button class="start-button" onclick="useCurrentLocationForNewHunt()" style="display: inline; padding: 5px 15px; margin: 0 5px;">
              Use Current Location
            </button>
          </p>
          <div class="location-controls">
            <div class="control-group">
              <label for="location-input">
                Selected Location:
              </label>
              <input
                type="text"
                id="location-input"
                readonly
                placeholder="Click on the map to select a location"
              />
            </div>
            <div class="control-group">
              <label for="radius-input">
                Play Area Radius: <span id="radius-value">${selectedRadius}</span> meters
              </label>
              <input
                type="range"
                id="radius-input"
                min="100"
                max="5000"
                step="50"
                value="${selectedRadius}"
                oninput="handleRadiusChange()"
              />
              <div class="range-labels">
                <span>100m</span>
                <span>5000m</span>
              </div>
            </div>
          </div>
          <div id="map"></div>
          <p style="margin-top: 20px;">Ready to start your adventure?</p>
          <button id="create-new-hunt-button" class="start-button" onclick="handleStart()" disabled>Create New Hunt</button>

          <div class="feature-selector">
            <h2>Hunt Length:</h2>
            <div class="feature-category">
              <div style="display: flex; gap: 20px; justify-content: center; flex-wrap: wrap;">
                <label class="hunt-length-option">
                  <input type="radio" name="hunt-length" value="short" onchange="selectedHuntLength = 'short'">
                  Short (4-6 stops)
                </label>
                <label class="hunt-length-option">
                  <input type="radio" name="hunt-length" value="medium" checked onchange="selectedHuntLength = 'medium'">
                  Medium (7-10 stops)
                </label>
                <label class="hunt-length-option">
                  <input type="radio" name="hunt-length" value="long" onchange="selectedHuntLength = 'long'">
                  Long (11-15 stops)
                </label>
              </div>
            </div>

            <div class="feature-category" style="margin-top: 20px;">
              <div class="feature-checkbox">
                <input type="checkbox" id="start-near-center" onchange="startNearCenter = this.checked" checked>
                <label for="start-near-center">Start hunt at POI closest to center point (useful when starting 
                  from your current location)</label>
              </div>
            </div>

            <h2>Select OSM Feature Tags to Include:</h2>

            <div class="feature-category">
              <h3>Tourism</h3>
              <div class="feature-checkboxes">
                <div class="feature-checkbox">
                  <input type="checkbox" id="tourism-yes" name="feature" value="tourism=yes" checked>
                  <label for="tourism-yes">Yes</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="tourism-artwork" name="feature" value="tourism=artwork" checked>
                  <label for="tourism-artwork">Artwork</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="tourism-viewpoint" name="feature" value="tourism=viewpoint" checked>
                  <label for="tourism-viewpoint">Viewpoint</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="tourism-attraction" name="feature" value="tourism=attraction" checked>
                  <label for="tourism-attraction">Attraction</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="tourism-information" name="feature" value="tourism=information" checked>
                  <label for="tourism-information">Information</label>
                </div>
              </div>
            </div>

            <div class="feature-category">
              <h3>Amenity</h3>
              <div class="feature-checkboxes">
                <div class="feature-checkbox">
                  <input type="checkbox" id="amenity-library" name="feature" value="amenity=library" checked>
                  <label for="amenity-library">Library</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="amenity-public_bookcase" name="feature" value="amenity=public_bookcase" checked>
                  <label for="amenity-public_bookcase">Public Bookcase</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="amenity-shower" name="feature" value="amenity=shower" checked>
                  <label for="amenity-shower">Shower</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="amenity-telephone" name="feature" value="amenity=telephone" checked>
                  <label for="amenity-telephone">Telephone</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="amenity-toilets" name="feature" value="amenity=toilets" checked>
                  <label for="amenity-toilets">Toilets</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="amenity-water_point" name="feature" value="amenity=water_point" checked>
                  <label for="amenity-water_point">Water Point</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="amenity-clock" name="feature" value="amenity=clock" checked>
                  <label for="amenity-clock">Clock</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="amenity-photo_booth" name="feature" value="amenity=photo_booth" checked>
                  <label for="amenity-photo_booth">Photo Booth</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="amenity-public_bath" name="feature" value="amenity=public_bath" checked>
                  <label for="amenity-public_bath">Public Bath</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="amenity-post_box" name="feature" value="amenity=post_box" checked>
                  <label for="amenity-post_box">Post Box</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="amenity-bench" name="feature" value="amenity=bench">
                  <label for="amenity-bench">Bench</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="amenity-dressing_room" name="feature" value="amenity=dressing_room" checked>
                  <label for="amenity-dressing_room">Dressing Room</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="amenity-parcel_locker" name="feature" value="amenity=parcel_locker" checked>
                  <label for="amenity-parcel_locker">Parcel Locker</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="amenity-watering_place" name="feature" value="amenity=watering_place" checked>
                  <label for="amenity-watering_place">Watering Place</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="amenity-fountain" name="feature" value="amenity=fountain" checked>
                  <label for="amenity-fountain">Fountain</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="amenity-grit_bin" name="feature" value="amenity=grit_bin" checked>
                  <label for="amenity-grit_bin">Grit Bin</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="amenity-vending_machine" name="feature" value="amenity=vending_machine" checked>
                  <label for="amenity-vending_machine">Vending Machine</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="amenity-place_of_worship" name="feature" value="amenity=place_of_worship" checked>
                  <label for="amenity-place_of_worship">Place of Worship</label>
                </div>
              </div>
            </div>

            <div class="feature-category">
              <h3>Building</h3>
              <div class="feature-checkboxes">
                <div class="feature-checkbox">
                  <input type="checkbox" id="building-clock_tower" name="feature" value="building=clock_tower" checked>
                  <label for="building-clock_tower">Clock Tower</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="building-shrine" name="feature" value="building=shrine" checked>
                  <label for="building-shrine">Shrine</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="building-church" name="feature" value="building=church" checked>
                  <label for="building-church">Church</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="building-cathedral" name="feature" value="building=cathedral" checked>
                  <label for="building-cathedral">Cathedral</label>
                </div>
              </div>
            </div>

            <div class="feature-category">
              <h3>Man Made</h3>
              <div class="feature-checkboxes">
                <div class="feature-checkbox">
                  <input type="checkbox" id="man_made-water_tap" name="feature" value="man_made=water_tap" checked>
                  <label for="man_made-water_tap">Water Tap</label>
                </div>
              </div>
            </div>

            <div class="feature-category">
              <h3>Historic</h3>
              <div class="feature-checkboxes">
                <div class="feature-checkbox">
                  <input type="checkbox" id="historic-memorial" name="feature" value="historic=memorial" checked>
                  <label for="historic-memorial">Memorial</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="historic-milestone" name="feature" value="historic=milestone" checked>
                  <label for="historic-milestone">Milestone</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="historic-highwater_mark" name="feature" value="historic=highwater_mark" checked>
                  <label for="historic-highwater_mark">Highwater Mark</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="historic-epigraph" name="feature" value="historic=epigraph" checked>
                  <label for="historic-epigraph">Epigraph</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="historic-church" name="feature" value="historic=church" checked>
                  <label for="historic-church">Church</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="historic-stone" name="feature" value="historic=stone" checked>
                  <label for="historic-stone">Stone</label>
                </div>
              </div>
            </div>

            <div class="feature-category">
              <h3>Information</h3>
              <div class="feature-checkboxes">
                <div class="feature-checkbox">
                  <input type="checkbox" id="information-board" name="feature" value="information=board" checked>
                  <label for="information-board">Board</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="information-stele" name="feature" value="information=stele" checked>
                  <label for="information-stele">Stele</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="information-terminal" name="feature" value="information=terminal" checked>
                  <label for="information-terminal">Terminal</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="information-map" name="feature" value="information=map" checked>
                  <label for="information-map">Map</label>
                </div>
                <div class="feature-checkbox">
                  <input type="checkbox" id="information-guidepost" name="feature" value="information=guidepost" checked>
                  <label for="information-guidepost">Guidepost</label>
                </div>
              </div>
            </div>
          </div>
          <div class="privacy" id="privacy">
            Privacy:<br />The starting area you choose for your treasure hunt is sent to the OpenStreetMap Overpass API.<br />
            No personal data is sent to this server, all is handled in the client.
          </div>
        </div>
      `;

      // Initialize map after DOM is updated
      initStartScreenMap(null);
    }

    // Render treasure hunt UI
    function renderTreasureHunt(state) {
      // Preserve UI state before rebuilding
      const useWatchPosition = document.getElementById('use-watch-position')?.checked || false;
      const debugVisible = document.getElementById('location-debug')?.style.display !== 'none';
      const locationAccuracyText = document.getElementById('location-accuracy')?.textContent || '';

      // Check if hunt is complete
      if (state.currentWaypointIndex >= state.waypoints.length) {
        const totalTime = Math.floor((Date.now() - state.startTime) / 1000 / 60); // minutes
        document.getElementById('app').innerHTML = `
          <div class="start-screen">
            <h1>Hunt Complete!</h1>
            <p>Congratulations! You found all ${state.waypoints.length} waypoints.</p>
            <div class="progress">
              <strong>Total Time:</strong> ${totalTime} minutes<br>
              <strong>Penalty Score:</strong> ${state.penaltyScore} points
            </div>
            <div id="map"></div>
            <h2>Waypoints Visited:</h2>
            <ul class="waypoint-list">
              ${state.waypoints.map((wp, i) => `
                <li class="waypoint-item completed">
                  <strong>${i + 1}. ${wp.name}</strong>
                </li>
              `).join('')}
            </ul>
            <div style="margin-top: 20px;">
              <button class="start-button" onclick="shareHunt()" style="margin: 5px;">Share This Hunt</button>
              <button class="start-button" onclick="resetHunt()" style="margin: 5px;">Start New Hunt</button>
            </div>
          </div>
        `;
        // Show the complete path on the map
        initHuntMap(state);
        return;
      }

      const currentWaypoint = state.waypoints[state.currentWaypointIndex];
      const progressPercent = (state.currentWaypointIndex / state.waypoints.length * 100).toFixed(0);

      document.getElementById('app').innerHTML = `
        <h1>${state.huntName}</h1>

        <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 5px; padding: 15px; margin: 20px 0;">
          <p style="margin: 0; font-style: italic;">
            "Oof, I had one drink too many last night and got lost. I just woke up near
            <strong>${state.waypoints[0].name}</strong> and am looking for another drink,
            and also my way home. Luckily I kind of remember where I live. It's a few stops, let me think...
          ${state.currentWaypointIndex == 0 ? 'First, come meet me at ' : 'Next, I need to find a '}  <strong>${currentWaypoint.name}</strong>..."
          </p>
        </div>

        <div class="progress">
          <div style="background: #ddd; border-radius: 10px; height: 20px; margin: 8px 0; overflow: hidden;">
            <div style="background: #4CAF50; height: 100%; width: ${progressPercent}%; transition: width 0.3s ease;"></div>
          </div>
          <strong>Progress:</strong> ${state.currentWaypointIndex} / ${state.waypoints.length} Waypoints
          <br /><strong>Penalty Score:</strong> ${state.penaltyScore} points
        </div>

        <div style="background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 20px 0;">
          <h2>Current Target:</h2>
          <p style="font-size: 18px; margin: 10px 0;"><strong>${currentWaypoint.name}</strong></p>
          <p style="font-size: 16px; margin: 5px 0;">
            <strong>Distance:</strong> ${state.distance ? Math.round(state.distance) : '?'} meters
          </p>
          <p style="font-size: 16px; margin: 5px 0;">
            <strong>Bearing:</strong> ${state.bearing ? state.bearing : '?'}° ${state.bearing ? getCompassDirection(state.bearing) : ''}
          </p>
        </div>

        <div style="margin: 15px 0;">
          <label style="font-size: 14px;">
            <input type="checkbox" id="use-watch-position" style="margin-right: 5px;">
            Use continuous tracking for up to 15 s (watchPosition). This seems to work better for Safari on iOS.
          </label>
        </div>

        <div id="firefox-notice" style="display: none; background: #ffcdcd; border: 1px solid #ffc107; border-radius: 5px; padding: 10px; margin: 10px 0; font-size: 14px;">
          <strong>Firefox Android users:</strong> Due to a browser bug, location accuracy may be poor.
          Workaround: Get precise location in Google Maps first, then switch back to Firefox within 10 seconds and hit the button.
        </div>

        <div style="margin: 20px 0;">
          <button id="check-location-btn" class="start-button" onclick="updateHuntLocation()" style="margin: 5px;">Check from live location</button>
          <button class="start-button" onclick="revealWaypoint()" style="margin: 5px;">Reveal it (penalty)</button>
          <button onclick="resetHunt()" style="margin: 5px; padding: 15px 30px;">Reset Hunt</button>
        </div>

        <div id="location-debug" style="margin: 10px 0; padding: 10px; background: #f5f5f5; border-radius: 5px; font-size: 14px; display: none;">
          <strong>Location Accuracy Debug Info:</strong>
          <span id="location-accuracy"></span>
        </div>

        <div id="map"></div>

        ${state.completed.length > 0 ? `
          <h2>Completed Waypoints:</h2>
          <ul class="waypoint-list">
            ${state.completed.map(idx => `
              <li class="waypoint-item completed">
                <strong>${idx + 1}. ${state.waypoints[idx].name}</strong>
              </li>
            `).join('')}
          </ul>
        ` : ''}
      `;

      // Restore UI state after rebuilding
      const watchCheckbox = document.getElementById('use-watch-position');
      if (watchCheckbox) {
        watchCheckbox.checked = useWatchPosition;
      }
      const debugDiv = document.getElementById('location-debug');
      if (debugDiv && debugVisible) {
        debugDiv.style.display = 'block';
      }
      const accuracySpan = document.getElementById('location-accuracy');
      if (accuracySpan && locationAccuracyText) {
        accuracySpan.textContent = locationAccuracyText;
      }

      // Detect Firefox and show notice
      if (navigator.userAgent.toLowerCase().indexOf('firefox') > -1) {
        const notice = document.getElementById('firefox-notice');
        if (notice) notice.style.display = 'block';
      }

      // Initialize map showing only completed waypoints and current location
      initHuntMap(state);
    }

    // Helper to convert bearing to compass direction
    function getCompassDirection(bearing) {
      const directions = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];
      const index = Math.round(bearing / 22.5) % 16;
      return directions[index];
    }

    // Initialize map for active hunt (show only completed waypoints + current location)
    function initHuntMap(state) {
      // Remove existing map if it exists (since the HTML was replaced)
      if (map) {
        map.remove();
        map = null;
      }

      // Clear existing markers
      markers = [];
      currentLocationMarker = null;
      accuracyCircle = null;

      // Create new map
      const center = state.currentLocation || state.waypoints[0];
      map = L.map('map').setView([center.lat, center.lng], 15);

      L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
        attribution: '© OpenStreetMap contributors, © CARTO',
        subdomains: 'abcd',
        maxZoom: 20
      }).addTo(map);

      // Always show first waypoint (starting point)
      const firstWaypoint = state.waypoints[0];
      const isFirstCompleted = state.completed.includes(0);

      if (!isFirstCompleted) {
        // Show orange marker for uncompleted first waypoint
        const orangeIcon = L.icon({
          iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-orange.png',
          shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          shadowSize: [41, 41]
        });
        const startMarker = L.marker([firstWaypoint.lat, firstWaypoint.lng], { icon: orangeIcon })
          .addTo(map)
          .bindPopup(`<b>Starting Point</b><br>${firstWaypoint.name}`);
        markers.push(startMarker);
      }

      // Add completed waypoint markers
      state.completed.forEach(idx => {
        const waypoint = state.waypoints[idx];
        const greenIcon = L.icon({
          iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-green.png',
          shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          shadowSize: [41, 41]
        });

        const marker = L.marker([waypoint.lat, waypoint.lng], { icon: greenIcon })
          .addTo(map)
          .bindPopup(`<b>${waypoint.name}</b><br>✓ Completed`);
        markers.push(marker);
      });

      // Draw path between completed waypoints
      if (state.completed.length > 1) {
        const pathCoords = state.completed.map(idx => [
          state.waypoints[idx].lat,
          state.waypoints[idx].lng
        ]);
        if (pathPolyline) {
          map.removeLayer(pathPolyline);
        }
        pathPolyline = L.polyline(pathCoords, {
          color: 'blue',
          weight: 4,
          opacity: 0.7
        }).addTo(map);
      }

      // Add current location marker if available
      if (state.currentLocation) {
        const blueIcon = L.icon({
          iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-blue.png',
          shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
          iconSize: [25, 41],
          iconAnchor: [12, 41],
          popupAnchor: [1, -34],
          shadowSize: [41, 41]
        });

        currentLocationMarker = L.marker([state.currentLocation.lat, state.currentLocation.lng], { icon: blueIcon })
          .addTo(map)
          .bindPopup('You are here');
        map.setView([state.currentLocation.lat, state.currentLocation.lng], 15);

        // Add accuracy circle if available
        if (state.currentLocation.accuracy) {
          accuracyCircle = L.circle([state.currentLocation.lat, state.currentLocation.lng], {
            color: 'blue',
            fillColor: '#0066ff',
            fillOpacity: 0.1,
            weight: 1,
            radius: state.currentLocation.accuracy
          }).addTo(map);
        }
      }

      // Fit map to show all markers
      if (markers.length > 0 || currentLocationMarker) {
        const allMarkers = [...markers];
        if (currentLocationMarker) allMarkers.push(currentLocationMarker);
        if (allMarkers.length > 0) {
          const bounds = L.latLngBounds(allMarkers.map(m => m.getLatLng()));
          map.fitBounds(bounds, { padding: [50, 50] });
        }
      }
    }

    // Helper Functions

    // Haversine distance formula - returns distance in meters
    function haversineDistance(lat1, lon1, lat2, lon2) {
      const R = 6371000; // Earth's radius in meters
      const φ1 = lat1 * Math.PI / 180;
      const φ2 = lat2 * Math.PI / 180;
      const Δφ = (lat2 - lat1) * Math.PI / 180;
      const Δλ = (lon2 - lon1) * Math.PI / 180;

      const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
        Math.cos(φ1) * Math.cos(φ2) *
        Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

      return R * c;
    }

    // Calculate bearing from point 1 to point 2 - returns degrees (0-360)
    function calculateBearing(lat1, lon1, lat2, lon2) {
      const φ1 = lat1 * Math.PI / 180;
      const φ2 = lat2 * Math.PI / 180;
      const Δλ = (lon2 - lon1) * Math.PI / 180;

      const y = Math.sin(Δλ) * Math.cos(φ2);
      const x = Math.cos(φ1) * Math.sin(φ2) -
        Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
      const θ = Math.atan2(y, x);
      const bearing = (θ * 180 / Math.PI + 360) % 360;

      return Math.round(bearing);
    }

    // Format waypoint description from OSM element
    function formatWaypointDescription(element) {
      const tags = element.tags || {};

      // Try to get a name
      if (tags.name) {
        // Find the main feature type
        const featureType = Object.keys(tags).find(key =>
          ['tourism', 'amenity', 'historic', 'building', 'man_made', 'information'].includes(key)
        );
        let description = '';
        if (featureType) {
          description = `${featureType}=${tags[featureType]}, name: ${tags.name}`;
        } else {
          description = `name: ${tags.name}`;
        }

        // Add artwork_type if available
        if (tags.artwork_type) {
          description += `, artwork_type=${tags.artwork_type}`;
        }

        return description;
      }

      // Try ref (e.g., for post boxes)
      // if (tags.ref) {
      //     const featureType = Object.keys(tags).find(key =>
      //         ['tourism', 'amenity', 'historic', 'building', 'man_made', 'information'].includes(key)
      //     );
      //     if (featureType) {
      //         return `${featureType}=${tags[featureType]}, ref: ${tags.ref}`;
      //     }
      // }

      // Just show the feature type
      const featureType = Object.keys(tags).find(key =>
        ['tourism', 'amenity', 'historic', 'building', 'man_made', 'information'].includes(key)
      );
      if (featureType) {
        let description = `${featureType}=${tags[featureType]}`;

        // Add artwork_type if available (even without name)
        if (tags.artwork_type) {
          description += `, artwork_type=${tags.artwork_type}`;
        }

        // Add level if available (some things are underground)
        if (tags.level) {
          description += `, level=${tags.level}`;
        }

        return description;
      }

      return 'Unknown waypoint';
    }

    // Solve TSP using Nearest Neighbor algorithm
    // If startNearPoint is provided, start from the waypoint closest to that point
    function solveTSP(waypoints, startNearPoint = null) {
      if (waypoints.length <= 2) return waypoints;

      const remaining = [...waypoints];
      const ordered = [];

      let startIndex;
      if (startNearPoint) {
        // Find waypoint closest to the given point
        let nearestDist = Infinity;
        startIndex = 0;
        for (let i = 0; i < remaining.length; i++) {
          const dist = haversineDistance(
            startNearPoint.lat, startNearPoint.lng,
            remaining[i].lat, remaining[i].lng
          );
          if (dist < nearestDist) {
            nearestDist = dist;
            startIndex = i;
          }
        }
      } else {
        // Start at a random point
        startIndex = Math.floor(Math.random() * remaining.length);
      }
      ordered.push(remaining.splice(startIndex, 1)[0]);

      // Greedily pick nearest unvisited waypoint
      while (remaining.length > 0) {
        const current = ordered[ordered.length - 1];
        let nearestIndex = 0;
        let nearestDist = Infinity;

        for (let i = 0; i < remaining.length; i++) {
          const dist = haversineDistance(
            current.lat, current.lng,
            remaining[i].lat, remaining[i].lng
          );
          if (dist < nearestDist) {
            nearestDist = dist;
            nearestIndex = i;
          }
        }

        ordered.push(remaining.splice(nearestIndex, 1)[0]);
      }

      return ordered;
    }

    // Format waypoint name with clustered alternates
    function formatClusteredWaypointName(primaryWaypoint, alternates) {
      let name = primaryWaypoint.name;

      if (alternates && alternates.length > 0) {
        // Group alternates by feature type
        const grouped = {};
        alternates.forEach(alt => {
          const feature = alt.name;
          grouped[feature] = (grouped[feature] || 0) + 1;
        });

        // Build suffix like "(+ amenity × 2, historic × 1)"
        const additions = Object.entries(grouped)
          .map(([feature, count]) => count > 1 ? `${feature} × ${count}` : feature)
          .join(', ');

        if (additions) {
          name += ` (+ ${additions})`;
        }
      }

      return name;
    }

    // Start button handler
    function handleStart() {
      (async () => {
        // Disable button during API call
        setCreateHuntButtonEnabled(false);

        const checkedFeatures = Array.from(
          document.querySelectorAll('input[name="feature"]:checked')
        ).map(checkbox => checkbox.value);

        console.log(checkedFeatures);

        console.log(selectedLocation);
        console.log(selectedRadius);

        // Create the request. Ex.:
        //
        // (
        //     node(around: 1000.0, 48.1351, 11.5820)[tourism = artwork];
        //     node(around: 1000.0, 48.1651, 11.5820)[historic = memorial];
        // );
        // out;

        const overpassQlRequest = "[out:json];\n(\n" +
          checkedFeatures
            .map(
              (val, idx, _) => "node(around: "
                + selectedRadius
                + ", "
                + selectedLocation.lat
                + ", "
                + selectedLocation.lng
                + ")["
                + val
                + "];")
            .join("\n")
          + "\n);\nout;";
        console.log(overpassQlRequest);

        const overpassServer = 'https://www.overpass-api.de/api/interpreter';
        const overpassServerAlt = 'https://overpass.private.coffee/api/interpreter';

        // Helper function to fetch from Overpass API
        async function fetchOverpass(server) {
          const response = await fetch(server + '?', {
            method: 'POST',
            headers: {
              'Accept': 'application/json',
              'Content-Type': 'text/plain'
            },
            body: overpassQlRequest
          });
          return response;
        }

        try {
          let api = await fetchOverpass(overpassServer);
          console.log('Overpass API response (raw):', api);

          // If 504 Gateway Timeout, retry once with alternate server
          if (api.status === 504) {
            console.log('Got 504 from primary server, retrying with alternate server...');
            api = await fetchOverpass(overpassServerAlt);
            console.log('Alternate Overpass API response (raw):', api);
          }

          // If still not ok, throw an error
          if (!api.ok) {
            throw new Error(`Overpass API returned status ${api.status}`);
          }

          const answer = await api.json();
          console.log('Overpass API response:', answer);

          // Check if we got any results
          if (!answer.elements || answer.elements.length === 0) {
            alert('No points of interest found in this area with the selected features. Try a different location or select more features.');
            setCreateHuntButtonEnabled(true);
            return;
          }

          // Step 2: Parse and assign preference scores
          let scoredWaypoints = answer.elements.map(element => {
            let score = 10; // default low priority
            const tags = element.tags || {};

            if (tags.information == "guidepost" || tags.amenity == "post_box") score = 5;
            else if (tags.amenity == "bench") score = 1;
            else if (tags.amenity == "vending_machine") score = 2;
            else if (tags.amenity == "parcel_locker" || tags.amenity == "grit_bin") score = 8;
            else if (tags.amenity == "place_of_worship") score = 15;
            else if (tags.historic || tags.building || tags.information || tags.amenity) score = 27;
            else if (tags.tourism || tags.man_made) score = 35;

            if (tags.display == "sundial") score = 35;

            if (tags.name || tags.description) score += 10;

            // hard to reach guidepost, e. g. U-Bahn
            if (tags.information == "guidepost" && tags.level) score = 1;

            // some clocks are indoors
            if (tags.indoor == "yes") score = 0;

            return {
              lat: element.lat,
              lng: element.lon,
              name: formatWaypointDescription(element),
              element: element, // keep full element for later reference
              score: score
            };
          });
          scoredWaypoints.sort((a, b) => b.score - a.score);
          console.log(scoredWaypoints);

          // Step 3: Cluster waypoints that are on top or very close to each other
          let clusteredWaypoints = [];
          scoredWaypoints.forEach((val, idx) => {
            let added = false;
            for (let i = 0; i < clusteredWaypoints.length; ++i) {
              if (haversineDistance(val.lat, val.lng, clusteredWaypoints[i][0].lat, clusteredWaypoints[i][0].lng) < 5.0) {
                clusteredWaypoints[i][1].push(val);
                added = true;
                break;
              }
            }
            if (!added) {
              clusteredWaypoints.push([val, []]);
            }
          });
          console.log(clusteredWaypoints);

          // TODO: use the alternate stops at the same location as "hints"

          // Step 4: Weighted random selection based on hunt length
          let minStops, maxStops;
          if (selectedHuntLength === 'short') {
            minStops = 4;
            maxStops = 6;
          } else if (selectedHuntLength === 'long') {
            minStops = 11;
            maxStops = 15;
          } else { // medium
            minStops = 7;
            maxStops = 10;
          }

          // Random count within the range, capped by available waypoints
          const desiredCount = Math.floor(Math.random() * (maxStops - minStops + 1)) + minStops;
          const targetCount = Math.min(desiredCount, clusteredWaypoints.length);
          const selectedWaypoints = [];

          // Create weighted pool
          const pool = [...clusteredWaypoints];
          for (let i = 0; i < targetCount && pool.length > 0; i++) {
            // Calculate total weight
            const totalWeight = pool.reduce((sum, wp) => sum + wp[0].score, 0);
            let random = Math.random() * totalWeight;

            // Select based on weight
            let selectedIndex = 0;
            for (let j = 0; j < pool.length; j++) {
              random -= pool[j][0].score;
              if (random <= 0) {
                selectedIndex = j;
                break;
              }
            }

            const cluster = pool.splice(selectedIndex, 1)[0];
            const primaryWaypoint = cluster[0];
            const alternates = cluster[1];

            // Enhance name with cluster info
            const enhancedWaypoint = {
              ...primaryWaypoint,
              name: formatClusteredWaypointName(primaryWaypoint, alternates)
            };

            selectedWaypoints.push(enhancedWaypoint);
          }

          console.log('Selected waypoints:', selectedWaypoints);

          // Step 4: Solve TSP (optionally starting from POI closest to center)
          const orderedWaypoints = solveTSP(selectedWaypoints, startNearCenter ? selectedLocation : null);
          console.log('TSP ordered waypoints:', orderedWaypoints);

          // Step 5: Create hunt state
          const initialState = {
            waypoints: orderedWaypoints,
            currentWaypointIndex: 0,
            completed: [],
            penaltyScore: 0,
            startTime: null, // Will be set when first waypoint is completed
            huntName: "Treasure Hunt",
            currentLocation: null,
            distance: null,
            bearing: null
          };

          // Start the hunt
          updateURLWithState(initialState);
          renderTreasureHunt(initialState);

        } catch (error) {
          console.error('Error fetching waypoints:', error);
          alert('Failed to fetch points of interest. Please try again.');
          setCreateHuntButtonEnabled(true);
        }
      })()
    }

    function updateLocationAndBearingToNextWaypoint(position) {
      const currentLat = position.lat;
      const currentLng = position.lng;
      const accuracy = position.accuracy || null;

      if (!currentState || currentState.currentWaypointIndex >= currentState.waypoints.length) {
        return;
      }

      // Get current target waypoint
      const targetWaypoint = currentState.waypoints[currentState.currentWaypointIndex];

      // Calculate distance and bearing
      const distance = haversineDistance(currentLat, currentLng, targetWaypoint.lat, targetWaypoint.lng);
      const bearing = calculateBearing(currentLat, currentLng, targetWaypoint.lat, targetWaypoint.lng);

      const newState = {
        ...currentState,
        currentLocation: { lat: currentLat, lng: currentLng, accuracy: accuracy },
        distance: distance,
        bearing: bearing
      };
      updateURLWithState(newState);
      renderTreasureHunt(newState);
    }

    // Helper function: Display location debug info
    function updateLocationDebug(accuracy, method) {
      const debugDiv = document.getElementById('location-debug');
      const accuracySpan = document.getElementById('location-accuracy');
      if (debugDiv && accuracySpan) {
        accuracySpan.textContent = `Accuracy: ${accuracy.toFixed(1)}m (${method})`;
        debugDiv.style.display = 'block';
      }
    }

    // Helper function: Clear location debug info
    function clearLocationDebug() {
      const debugDiv = document.getElementById('location-debug');
      if (debugDiv) debugDiv.style.display = 'none';
    }

    // Helper function: Set button state
    function setLocationButtonEnabled(enabled) {
      const btn = document.getElementById('check-location-btn');
      if (btn) {
        btn.disabled = !enabled;
        btn.textContent = enabled ? 'Check from live location' : 'Acquiring location...';
      }
    }

    // Helper function: Set Use Current Location button state
    function setUseCurrentLocationButtonEnabled(enabled) {
      const btn = document.querySelector('.start-screen .start-button[onclick="useCurrentLocationForNewHunt()"]');
      if (btn) {
        btn.disabled = !enabled;
        btn.textContent = enabled ? 'Use Current Location' : 'Acquiring location...';
      }
    }

    // Helper function: Set Create New Hunt button state
    function setCreateHuntButtonEnabled(enabled, text = null) {
      const btn = document.getElementById('create-new-hunt-button');
      if (btn) {
        btn.disabled = !enabled;
        if (text) {
          btn.textContent = text;
        } else {
          btn.textContent = enabled ? 'Create New Hunt' : 'Creating hunt...';
        }
      }
    }

    // Update location during hunt
    function updateHuntLocation() {
      if (!currentState || currentState.currentWaypointIndex >= currentState.waypoints.length) {
        return;
      }

      if (!('geolocation' in navigator)) {
        alert('Geolocation is not supported by your browser');
        return;
      }

      // Disable button during acquisition
      setLocationButtonEnabled(false);

      // Check if user wants to use watchPosition mode
      const useWatchPosition = document.getElementById('use-watch-position')?.checked || false;

      // Get current target waypoint
      const targetWaypoint = currentState.waypoints[currentState.currentWaypointIndex];

      // Common function to apply game logic after getting position
      function applyGameLogic(currentLat, currentLng, accuracy) {
        // Calculate distance and bearing
        const distance = haversineDistance(currentLat, currentLng, targetWaypoint.lat, targetWaypoint.lng);
        const bearing = calculateBearing(currentLat, currentLng, targetWaypoint.lat, targetWaypoint.lng);

        // Determine auto-find threshold (10 - 20 m depending on GPS accuracy)
        const threshold = Math.min(20, Math.max(10, accuracy));

        console.log(`Distance: ${distance}m, Threshold: ${threshold}m`);

        if (distance <= threshold) {
          // Auto-found! No penalty
          alert(`You found it! ${targetWaypoint.name}`);
          const newState = {
            ...currentState,
            completed: [...currentState.completed, currentState.currentWaypointIndex],
            currentWaypointIndex: currentState.currentWaypointIndex + 1,
            currentLocation: { lat: currentLat, lng: currentLng, accuracy: accuracy },
            // Start timer when first waypoint is completed
            startTime: currentState.currentWaypointIndex === 0 ? Date.now() : currentState.startTime,
            distance: null,
            bearing: null
          };
          updateURLWithState(newState);
          renderTreasureHunt(newState);
        } else {
          // Not there yet - calculate penalty
          let penalty = 10; // default
          if (distance < 50) penalty = 3;
          else if (distance < 150) penalty = 5;
          else if (distance < 300) penalty = 7;
          else penalty = 10;

          const newState = {
            ...currentState,
            penaltyScore: currentState.penaltyScore + penalty
          };
          updateURLWithState(newState);
          renderTreasureHunt(newState);
        }

        // Display the distance and bearing towards the next waypoint from current position
        updateLocationAndBearingToNextWaypoint({ lat: currentLat, lng: currentLng, accuracy: accuracy });

        // Re-enable button
        setLocationButtonEnabled(true);
      }

      // Error handler
      function handleError(error) {
        alert('Could not get your location: ' + error.message);
        setLocationButtonEnabled(true);
      }

      if (useWatchPosition) {
        // watchPosition mode: continuous tracking for up to 15s, stop early if accuracy < 15m
        console.log('Using watchPosition mode');

        let watchStartTime = null;
        const MAX_WATCH_DURATION = 15000; // 15 seconds
        const ACCURACY_TARGET = 15; // meters

        currentWatchId = navigator.geolocation.watchPosition(
          (position) => {
            const currentLat = position.coords.latitude;
            const currentLng = position.coords.longitude;
            const accuracy = position.coords.accuracy;

            // Start timer on first position (after permission granted)
            if (watchStartTime === null) {
              watchStartTime = Date.now();
              console.log('Started 15s watch timer');
            }

            const elapsed = Date.now() - watchStartTime;

            // Update debug info
            updateLocationDebug(accuracy, 'watchPosition');
            console.log(`watchPosition update: ${accuracy.toFixed(1)}m accuracy (${(elapsed / 1000).toFixed(1)}s elapsed)`);

            // Update visual feedback on map
            updateLocationAndBearingToNextWaypoint({
              lat: currentLat,
              lng: currentLng,
              accuracy: accuracy
            });

            // Check stop conditions
            const shouldStop = accuracy < ACCURACY_TARGET || elapsed >= MAX_WATCH_DURATION;

            if (shouldStop) {
              if (accuracy < ACCURACY_TARGET) {
                console.log(`Accuracy target reached: ${accuracy.toFixed(1)}m`);
              } else {
                console.log(`Max watch duration reached: ${(elapsed / 1000).toFixed(1)}s`);
              }

              // Clear watch
              navigator.geolocation.clearWatch(currentWatchId);
              currentWatchId = null;

              // Apply game logic with final position
              applyGameLogic(currentLat, currentLng, accuracy);
            }
          },
          (error) => {
            // Clear watch on error
            if (currentWatchId !== null) {
              navigator.geolocation.clearWatch(currentWatchId);
              currentWatchId = null;
            }
            handleError(error);
          },
          {
            enableHighAccuracy: true,
            timeout: 5000,
            maximumAge: 0
          }
        );
      } else {
        // getCurrentPosition mode: single position request, no retries
        console.log('Using getCurrentPosition mode');

        navigator.geolocation.getCurrentPosition(
          (position) => {
            const currentLat = position.coords.latitude;
            const currentLng = position.coords.longitude;
            const accuracy = position.coords.accuracy;

            console.log(`getCurrentPosition: ${accuracy.toFixed(1)}m accuracy`);

            // Update debug info
            updateLocationDebug(accuracy, 'getCurrentPosition');

            // Apply game logic immediately
            applyGameLogic(currentLat, currentLng, accuracy);
          },
          handleError,
          {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 0
          }
        );
      }
    }

    // Mark current waypoint as found (manual)
    function revealWaypoint() {
      if (!currentState || currentState.currentWaypointIndex >= currentState.waypoints.length) {
        return;
      }

      const oldWaypoint = currentState.waypoints[currentState.currentWaypointIndex];

      const penalty = 15;

      const newState = {
        ...currentState,
        completed: [...currentState.completed, currentState.currentWaypointIndex],
        currentWaypointIndex: currentState.currentWaypointIndex + 1,
        currentLocation: currentState.currentLocation ?
          { lat: currentState.currentLocation.lat, lng: currentState.currentLocation.lng, accuracy: null } :
          null,
        // Start timer when first waypoint is completed
        startTime: currentState.currentWaypointIndex === 0 ? Date.now() : currentState.startTime,
        penaltyScore: currentState.penaltyScore + penalty,
        distance: null,
        bearing: null
      };
      updateURLWithState(newState);
      renderTreasureHunt(newState);

      // also show location from found waypoint to next one
      updateLocationAndBearingToNextWaypoint(oldWaypoint);
    }

    // Get current location
    function getCurrentLocation() {
      if ('geolocation' in navigator) {
        navigator.geolocation.getCurrentPosition(
          (position) => {
            const newState = {
              ...currentState,
              currentLocation: {
                lat: position.coords.latitude,
                lng: position.coords.longitude,
                accuracy: position.coords.accuracy
              }
            };

            updateURLWithState(newState);
            renderTreasureHunt(newState);
          },
          (error) => {
            alert('Could not get your location: ' + error.message);
          }
        );
      } else {
        alert('Geolocation is not supported by your browser');
      }
    }

    // Share hunt by copying a cleaned up URL to clipboard
    function shareHunt() {
      if (!currentState) return;

      // Create a clean state with just the waypoints (no progress)
      const cleanState = {
        waypoints: currentState.waypoints,
        currentWaypointIndex: 0,
        completed: [],
        penaltyScore: 0,
        startTime: null,
        huntName: currentState.huntName,
        currentLocation: null,
        distance: null,
        bearing: null
      };

      // Encode and create full URL based on current URL
      const encoded = encodeState(cleanState);
      const url = new URL(window.location.href);
      url.searchParams.set('state', encoded);
      const shareURL = url.toString();

      // Copy to clipboard
      navigator.clipboard.writeText(shareURL).then(() => {
        alert('Hunt URL copied to clipboard!');
      }).catch(err => {
        // Fallback for older browsers
        console.error('Failed to copy:', err);
        prompt('Copy this URL to share the hunt:', shareURL);
      });
    }

    // Reset hunt
    function resetHunt() {
      if (confirm('Are you sure you want to reset the hunt?')) {
        window.history.replaceState(null, '', window.location.pathname);
        currentState = null;

        // Clear selected location and markers
        if (map) {
          if (selectedLocationMarker) {
            map.removeLayer(selectedLocationMarker);
          }
          if (selectedAreaCircle) {
            map.removeLayer(selectedAreaCircle);
          }
        }
        selectedLocation = null;
        selectedLocationMarker = null;
        selectedAreaCircle = null;

        map = null;
        renderStartScreen();
      }
    }

    // Initialize app
    function initApp() {
      const state = getStateFromURL();

      if (state) {
        currentState = state;
        renderTreasureHunt(state);
      } else {
        renderStartScreen();
      }
    }

    // Start when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initApp);
    } else {
      initApp();
    }
  </script>
</body>

</html>
